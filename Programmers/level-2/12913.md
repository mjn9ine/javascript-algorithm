# [Programmers] 땅따먹기

프로그래머스(Programmers) : https://programmers.co.kr/learn/courses/30/lessons/12913

### 문제

땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.

예를 들면,

| 1 | 2 | 3 | 5 |

| 5 | 6 | 7 | 8 |

| 4 | 3 | 2 | 1 |

로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.

마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.

### 제한 조건

- 행의 개수 N : 100,000 이하의 자연수
- 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.
- 점수 : 100 이하의 자연수

### 입출력 예

|              land               | answer |
| :-----------------------------: | :----: |
| [[1,2,3,5],[5,6,7,8],[4,3,2,1]] |   16   |

### 입출력 예 설명

#### 입출력 예 #1

문제의 예시와 같습니다.

## 2. 내 소스 코드

```javascript
function solution(land) {
  var answer = 0;
  // 먼저 dp배열을 land의 첫번째 행으로 초기화해준다.
  const dp = [land[0]];
  // land배열의 1번째 인덱스부터 forEach문을 이용해 순회한다.
  land.slice(1).forEach((row, i) => {
    // dp배열에 추가해줄 임시 배열인 tmp를 만들어준다.
    const tmp = [];
    // land배열을 순회하면서 받은 값인 row는 한 행(배열)을 의미한다.
    row.forEach((score, j) => {
      // row에서 다시 한번 forEach문을 이용해 각 점수들을 score로 받아준다.
      // 이제 tmp에 (해당 칸의 점수 + dp의 마지막 행 중 같은 열이 아닌 점수의 최댓값)을 넣어준다.
      tmp.push(score + Math.max(...dp[i].filter((_, k) => k !== j)));
    });
    dp.push(tmp);
  });
  // 마지막으로 answer에 dp에 쌓인 마지막 행에서 가장 큰 값을 넣어준다.
  answer = Math.max(...dp[land.length - 1]);
  return answer;
}
```

## 3. 풀이 & 개선점

이 문제는 다이나믹 프로그래밍을 이용해 해결할 수 있었다. DP는 어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는 방식의 알고리즘을 총칭한다고 한다.
여기서는 `dp`라는 배열의 마지막 행을 계속해서 이용함으로써 게임의 규칙인 같은 열을 연속해서 밟지 않고 가장 많이 얻을 수 있는 점수를 구할 수 있었다.
