# [Programmers] 교점에 별 만들기

프로그래머스(Programmers) : https://programmers.co.kr/learn/courses/30/lessons/87377

### 문제 설명

Ax + By + C = 0으로 표현할 수 있는 n개의 직선이 주어질 때, 이 직선의 교점 중 정수 좌표에 별을 그리려 합니다.

예를 들어, 다음과 같은 직선 5개를

- 2x - y + 4 = 0
- -2x - y + 4 = 0
- -y + 1 = 0
- 5x - 8y - 12 = 0
- 5x + 8y + 12 = 0

좌표 평면 위에 그리면 아래 그림과 같습니다.

이때, 모든 교점의 좌표는 (4, 1), (4, -4), (-4, -4), (-4, 1), (0, 4), (1.5, 1.0), (2.1, -0.19), (0, -1.5), (-2.1, -0.19), (-1.5, 1.0)입니다. 이 중 정수로만 표현되는 좌표는 (4, 1), (4, -4), (-4, -4), (-4, 1), (0, 4)입니다.

만약 정수로 표현되는 교점에 별을 그리면 다음과 같습니다.

위의 그림을 문자열로 나타낼 때, 별이 그려진 부분은 \*, 빈 공간(격자선이 교차하는 지점)은 .으로 표현하면 다음과 같습니다.

```
"..........."
".....*....."
"..........."
"..........."
".*.......*."
"..........."
"..........."
"..........."
"..........."
".*.......*."
"..........."
```

이때 격자판은 무한히 넓으니 모든 별을 포함하는 최소한의 크기만 나타내면 됩니다.

따라서 정답은

```
"....*...."
"........."
"........."
"*.......*"
"........."
"........."
"........."
"........."
"*.......*"
```

입니다.

직선 A, B, C에 대한 정보가 담긴 배열 line이 매개변수로 주어집니다. 이때 모든 별을 포함하는 최소 사각형을 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- line의 세로(행) 길이는 2 이상 1,000 이하인 자연수입니다.
  - line의 가로(열) 길이는 3입니다.
  - line의 각 원소는 [A, B, C] 형태입니다.
  - A, B, C는 -100,000 이상 100,000 이하인 정수입니다.
  - 무수히 많은 교점이 생기는 직선 쌍은 주어지지 않습니다.
  - A = 0이면서 B = 0인 경우는 주어지지 않습니다.
- 정답은 1,000 \* 1,000 크기 이내에서 표현됩니다.
- 별이 한 개 이상 그려지는 입력만 주어집니다.

### 입출력 예

|                              line                               |                                                        result                                                         |
| :-------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------: |
| [[2, -1, 4], [-2, -1, 4], [0, -1, 1], [5, -8, -12], [5, 8, 12]] | ["....*....", ".........", ".........", "*.......*", ".........", ".........", ".........", ".........", "*.......*"] |
|               [[0, 1, -1], [1, 0, -1], [1, 0, 1]]               |                                                        ["*.*"]                                                        |
|                    [[1, -1, 0], [2, -1, 0]]                     |                                                         ["*"]                                                         |
|              [[1, -1, 0], [2, -1, 0], [4, -1, 0]]               |                                                         ["*"]                                                         |

### 입출력 예 설명

#### 입출력 예 #1

문제 예시와 같습니다.

#### 입출력 예 #2

직선 y = 1, x = 1, x = -1는 다음과 같습니다.

(-1, 1), (1, 1) 에서 교점이 발생합니다.

따라서 정답은

```
"*.*"
```

입니다.

#### 입출력 예 #3

직선 y = x, y = 2x는 다음과 같습니다.

(0, 0) 에서 교점이 발생합니다.

따라서 정답은

```
"*"
```

입니다.

#### 입출력 예 #4

직선 y = x, y = 2x, y = 4x는 다음과 같습니다.

(0, 0) 에서 교점이 발생합니다.

따라서 정답은

```
"*"
```

입니다.

### _참고 사항_

`Ax + By + E = 0`
`Cx + Dy + F = 0`

두 직선의 교점이 유일하게 존재할 경우, 그 교점은 다음과 같습니다.

`x = BF - ED / AD - BC`
`y = EC - AF / AD - BC`

또, AD - BC = 0인 경우 두 직선은 평행 또는 일치합니다.

## 2. 내 소스 코드

```javascript
function solution(line) {
  var answer = [];
  // 교점들의 배열을 만들어준다.
  const intersectionSet = [];

  // 격자판의 최소한의 크기를 구하기 위해서 x, y좌표의 최대, 최소값을 구해준다.
  let minX = Number.MAX_SAFE_INTEGER,
    minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER,
    maxY = Number.MIN_SAFE_INTEGER;

  // 두 개의 직선을 선택하기 위한 작업.
  const tmpArr = Array.from({ length: line.length }, (_, i) => i);
  // 두 개의 직선을 선택했다면 두 직선의 교점을 구하고, 조건에 부합하는지 확인한다.
  combination(tmpArr, 2).map(([first, second]) => {
    // 참고 사항에 나와 있는 공식을 이용한다.
    const [a, b, p] = line[first];
    const [c, d, q] = line[second];

    // 두 직선이 평행하거나 일치할 경우
    // 문제의 조건에서 일치하는 경우는 주어지지 않는다고 나와있고, 평행할 경우에는 교점이 없다.
    if (a * d - b * c === 0) return;

    // 그렇지 않은 경우 교점이 아래와 같이 유일하게 존재한다.
    const x = (b * q - p * d) / (a * d - b * c);
    const y = (p * c - a * q) / (a * d - b * c);

    // 교점 중 정수 좌표에만 별을 그리기 때문에 좌표가 각각 정수인지 판별한다.
    if (Number.isInteger(x) && Number.isInteger(y)) {
      intersectionSet.push([x, y]);
      // 격자판의 크기를 최소화하기 위한 최대, 최소값을 업데이트 시켜준다.
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    }
  });

  // 격자판을 최소한의 크기로 만들어준다.
  // 이 때, x와 y는 우리가 흔히 쓰던 j와 i라고 생각하면 편하다.
  const intersectionMap = Array.from(Array(maxY - minY + 1), () =>
    Array(maxX - minX + 1).fill(".")
  );

  // 교점들의 집합에서 x, y좌표를 행렬에 맞게끔 변환시켜준다.
  intersectionSet.map(([curX, curY]) => {
    // 위에서 말했듯이 x좌표는 평소의 배열에서 j(가로), y좌표는 i(세로)를 뜻한다.
    const intersectionMapX = curX - minX;
    const intersectionMapY = maxY - curY;

    intersectionMap[intersectionMapY][intersectionMapX] = "*";
  });

  // 문제의 출력 포맷에 맞춰 배열에서 각 행의 원소들을 하나의 문자열로 표현해준다.
  answer = intersectionMap.reduce((acc, row) => {
    acc.push(row.join(""));
    return acc;
  }, []);

  return answer;
}

// n개의 직선이 주어질 때, 2개의 직선을 고를 수 있도록 조합을 이용한다.
function combination(arr, num) {
  const res = [];
  if (num === 1) return arr.map((elem) => [elem]);

  arr.map((v, idx, origin) => {
    const rest = origin.slice(idx + 1);
    const combinations = combination(rest, num - 1);
    const attach = combinations.map((combination) => [v, ...combination]);
    res.push(...attach);
  });
  return res;
}
```

## 3. 풀이 & 개선점

이 문제는 Array 객체의 메서드들을 굉장히 많이 사용해볼 수 있는 문제였다. forEach는 원본배열을 조작할 수 있기 때문에 map을 이용해서 하려고 했다.
교점들의 집합을 구하는 과정에서는 Set 객체를 사용하고 싶었는데 배열의 중복은 처리하지 않아서 그냥 배열로 처리해줬다. 중복을 애초에 없애주면 나중에 계속해서 같은 위치에 '\*'를 찍어줄 필요가 없어져 좋을 것 같은데 방법을 알아봐야 할 것 같다.
